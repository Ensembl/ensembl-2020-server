import "lib:std";
use "std";

enum etest { X: string, Y: vec(boolean) };
enum etest2 { Z: etest, W: boolean };

struct stest { A: vec(number), B: etest };
struct zstest2 { M: stest };
enum etest3 { A: stest, B: etest, C: boolean, D: vec(vec(number)) };

func len(vec(_)) becomes number;
proc bool_check(boolean);
func oper_test(stest) becomes stest;

// assign a simple non-vector quantity: smoke test.
// properties: unfiltered
e := 1;
print_regs(e); // 1
print_vec(e);

// assignments only get the first value of a multivalue.
// properties: unfiltered
e := [2,3][];
print_regs(e); // 2
print_vec(e);

// assign a simple, one-dimensional vector quantity.
// properties: unfiltered
e := [4,5];
print_regs(e); // [4,5]
print_vec(e);
// reassign all values using reffilter (repeated)
// properties: filtered
e[] := 6;
print_regs(e); // [6,6]
print_vec(e);

// reassign all values using reffilter (iterated)
// properties: filtered
e[] := [7,8][];
print_regs(e); // [7,8]
print_vec(e);

// XXX structs & enums

// reassign some values using explicit reffitler
e[@==1] := 9;
print_regs(e); // [7,9]
print_vec(e);

// good smoke test of at
e := [[1,2],[3,4]];
print_vec(e[@<3][@==1]);

// big mutli-dimensional vector
e := [[[111,112,113],[121,122,123],[131,132,133]],
      [[211,212,213],[221,222,223],[231,232,233]],
      [[311,312,313],[321,322,323],[331,332,333]]];
print_regs(e); // ...
print_vec(e);

// reassign final row
e[@==2] := [[411,412,413],[421,422,423],[431,432,433]];
print_regs(e); // 3xx -> 4xx
print_vec(e);

// reassign middle triple
e[][@==1] := [444];
print_regs(e);  // [x21,x22,x23] -> [444] (x3)
print_vec(e);

// reassign single value by multiple position params
e[@==0][@==2][@==2] := 433;
print_regs(e); // 133 -> 433
print_vec(e);

// reassign by repeated filter at same level
e[@==1][@==0][@==0] := 200;
print_regs(e); // 211 -> 200
print_vec(e);

// 3d to exercise non-top copying
e := [[[1,2],[3,4]],[[5,6],[7,8]]];
print_regs(e);
print_vec(e);

// nontop-vec copying
// properties: filtered nontop-vec
e[] := [[0,0,0],[9,9,9],[0,0,0]];
print_regs(e);
print_vec(e);

// test print_vec
print_vec([[[1,2,3],[4,5],[6],[]],[[7]]]);

// test len
e := [1,2,3];
print_vec([len(e)]);

// test dollar: simple
e := [1,2,3];
print_vec([e[@>0]&[$<3]]);

// test dollar: vecs and assign
e := [[],[1,2],[3],[]];
e[@>0]&[len($)==0] := [4];
print_vec(e);
